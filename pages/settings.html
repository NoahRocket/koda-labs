<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Settings - Koda Tutor</title>
  <link rel="stylesheet" href="../styles/main.css">
  <link rel="stylesheet" href="../styles/navbar.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <script src="../scripts/utils.js" defer></script>
  <style>
    /* Toast styling */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      max-width: 300px;
    }
    
    .toast {
      margin-bottom: 10px;
      padding: 12px;
      border-radius: 4px;
      color: white;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      opacity: 0;
      transform: translateY(-20px);
      transition: opacity 0.3s, transform 0.3s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .toast.active {
      opacity: 1;
      transform: translateY(0);
    }
    
    .toast.toast-closing {
      opacity: 0;
      transform: translateY(-20px);
    }
    
    .toast.success {
      background-color: #4caf50;
    }
    
    .toast.error {
      background-color: #f44336;
    }
    
    .toast.info {
      background-color: #2196f3;
    }
    
    .toast-content {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .toast-close-btn {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      padding: 0;
    }
  </style>
</head>
<body class="bg-gray-50 font-eb-garamond min-h-screen flex">
  <!-- Toast Container -->
  <div id="toastContainer" class="toast-container"></div>
  <!-- Mobile Hamburger -->
  <div class="md:hidden fixed top-4 left-4 z-50 cursor-pointer p-2 mobile-touch-target" id="hamburger">
    <div class="w-6 h-0.5 bg-gray-800 mb-1"></div>
    <div class="w-6 h-0.5 bg-gray-800 mb-1"></div>
    <div class="w-6 h-0.5 bg-gray-800"></div>
  </div>

  <!-- Sidebar Navigation -->
  <div id="sidebar" class="fixed top-0 left-0 h-screen w-64 app-sidebar transform -translate-x-full md:translate-x-0 transition-transform duration-300 z-40">
    <div class="flex flex-col h-full">
      <div class="logo-container pt-12 md:pt-5">
        <h1 class="app-logo">Koda <span>Tutor</span></h1>
        <button id="closeSidebar" class="absolute top-5 right-4 text-gray-300 hover:text-white md:hidden mobile-touch-target">
          <i class="fas fa-times"></i>
        </button>
      </div>
      
      <!-- User Avatar Display -->
      <div class="p-4 flex justify-center border-b border-gray-700">
        <div class="w-10 h-10 rounded-full bg-gray-600 flex items-center justify-center overflow-hidden" id="settingsAvatarContainer">
          <img id="settingsSidebarUserAvatar" src="" alt="User Avatar" class="w-full h-full object-cover opacity-0 transition-opacity duration-300" title="Avatar">
          <!-- Loading indicator -->
          <div id="settingsAvatarLoading" class="absolute">
            <i class="fas fa-circle-notch fa-spin text-gray-400"></i>
          </div>
        </div>
      </div>
      
      <nav class="flex-1 overflow-y-auto py-4">
        <ul class="space-y-1 px-4">
          <li id="loggedInNav" class="hidden flex-col space-y-1">
            <a href="dashboard.html" class="nav-link">
              <i class="fas fa-compass"></i>
              <span class="mobile-readable">Dashboard</span>
            </a>
            <a href="chat.html" class="nav-link">
              <i class="fas fa-comments"></i>
              <span class="mobile-readable">Chat</span>
            </a>
            <a href="bookmarks.html" class="nav-link">
              <i class="fas fa-bookmark"></i>
              <span class="mobile-readable">Bookmarks</span>
            </a>
            <a href="#" id="notesToggle" class="nav-link">
              <i class="fas fa-sticky-note"></i>
              <span class="mobile-readable">Notes</span>
            </a>
            <a href="podcasts.html" class="nav-link">
              <i class="fas fa-podcast"></i>
              <span class="mobile-readable">Podcasts</span>
            </a>
            <a href="settings.html" class="nav-link active">
              <i class="fas fa-cog"></i>
              <span class="mobile-readable">Settings</span>
            </a>
          </li>
          <li id="loggedOutNav" class="hidden flex-col space-y-1">
            <a href="login.html" class="nav-link">
              <i class="fas fa-sign-in-alt"></i>
              <span>Login</span>
            </a>
            <a href="signup.html" class="nav-link">
              <i class="fas fa-user-plus"></i>
              <span>Sign Up</span>
            </a>
          </li>
        </ul>
      </nav>
      
      <div class="p-4 border-t border-gray-700">
        <button id="logout" class="logout-btn w-full">
          <i class="fas fa-sign-out-alt"></i>
          <span>Logout</span>
        </button>
      </div>
    </div>
  </div>

  <main class="md:ml-64 flex-1 p-8 pt-20 md:pt-8">
    <h1 class="text-3xl font-bold mb-8 text-gray-800">Settings</h1>
    
    <!-- Tutor Avatar Settings -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-8">
      <h2 class="text-xl font-semibold mb-4 text-gray-700">Your Koda</h2>
      <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg">
        <div>
          <div class="font-medium text-gray-800">Customize Avatar</div>
          <div class="text-sm text-gray-600 mt-1">Personalize your Tutor's appearance.</div>
        </div>
        <button id="showCustomizeAvatarModalSettings" style="background-color:#00A3E0;" class="hover:bg-blue-600 text-white px-4 py-2 rounded-md transition-colors duration-200 flex items-center">
          <i class="fas fa-user-edit mr-2"></i> Customize
        </button>
      </div>
    </div>
    
    <!-- Blue Divider -->
    <hr style="border:none; height:1px; background-color:#00A3E0; margin:32px 0;">
    
    <div class="bg-white rounded-lg shadow-md p-6 mb-8">
      <h2 class="text-xl font-semibold mb-4 text-gray-700">Topic Management</h2>
      <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg">
        <div>
          <div class="font-medium text-gray-800">Manage Topics</div>
          <div class="text-sm text-gray-600 mt-1">Create, edit, or delete your learning topics</div>
        </div>
        <button id="manageTopicsBtn" style="background-color:#00A3E0;" class="hover:bg-blue-600 text-white px-4 py-2 rounded-md transition-colors duration-200 flex items-center">
          <i class="fas fa-cog mr-2"></i> Manage
        </button>
      </div>
      <div class="topic-management hidden mt-6" id="topicManagement">
        <div class="flex gap-4 mb-4">
          <input type="text" id="newTopicInput" placeholder="Enter new topic name" class="flex-1 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-transparent">
          <button id="addTopicBtn" style="background-color:#00A3E0;" class="hover:bg-blue-600 text-white px-4 py-2 rounded-md transition-colors duration-200">Add Topic</button>
        </div>
        <div class="topic-list" id="topicList">
          <!-- Topics will be loaded here -->
        </div>
      </div>
    </div>
    <!-- Blue Divider -->
    <hr style="border:none; height:1px; background-color:#00A3E0; margin:32px 0;">
    
    <!-- Subscription Management Section -->
    <div class="bg-white rounded-lg shadow-md p-6 mb-8">
      <h2 class="text-xl font-semibold mb-4 text-gray-700">Subscription</h2>
      <div id="subscriptionStatus" class="bg-gray-50 p-4 rounded-lg mb-4">
        <div class="flex items-center justify-between">
          <div>
            <div id="currentPlan" class="font-medium text-gray-800">Loading subscription info...</div>
            <div id="subscriptionDetails" class="text-sm text-gray-600 mt-1"></div>
          </div>
          <div class="badge bg-gray-200 text-gray-700 px-3 py-1 rounded-full text-sm" id="subscriptionBadge">
            Loading...
          </div>
        </div>
      </div>
      <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg">
        <div>
          <div class="font-medium text-gray-800">Manage Subscription</div>
          <div class="text-sm text-gray-600 mt-1">Upgrade, downgrade, or cancel your subscription</div>
        </div>
        <div class="flex space-x-2">
          <a href="/pages/pricing.html" style="background-color:#00A3E0;" class="hover:bg-blue-600 text-white px-4 py-2 rounded-md transition-colors duration-200 flex items-center" id="upgradePlanBtn">
            <i class="fas fa-arrow-up mr-2"></i> View Plans
          </a>
          <button id="manageSubscriptionBtn" style="background-color:#4B5563;" class="hover:bg-gray-600 text-white px-4 py-2 rounded-md transition-colors duration-200 flex items-center">
            <i class="fas fa-cog mr-2"></i> Manage
          </button>
        </div>
      </div>
    </div>
    
    <!-- Blue Divider -->
    <hr style="border:none; height:1px; background-color:#00A3E0; margin:32px 0;">
    <div class="bg-white rounded-lg shadow-md p-6 mb-8">
      <h2 class="text-xl font-semibold mb-4 text-gray-700">Account Settings</h2>
      <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg mb-4">
        <div>
          <div class="font-medium text-gray-800">Change Password</div>
          <div class="text-sm text-gray-600 mt-1">Update your account password</div>
        </div>
        <button id="changePassword" style="background-color:#00A3E0;" class="hover:bg-blue-600 text-white px-4 py-2 rounded-md transition-colors duration-200 flex items-center">
          <i class="fas fa-key mr-2"></i> Update
        </button>
      </div>
      <div class="flex justify-between items-center bg-gray-50 p-4 rounded-lg">
        <div>
          <div class="font-medium text-gray-800">Delete Account</div>
          <div class="text-sm text-gray-600 mt-1">Permanently delete your account and all associated data</div>
        </div>
        <button id="deleteAccount" style="background-color:#E53E3E;" class="hover:bg-red-700 text-white px-4 py-2 rounded-md transition-colors duration-200 flex items-center">
          <i class="fas fa-trash mr-2"></i> Delete
        </button>
      </div>
    </div>
  </main>

  <script>
    // Get user info from localStorage
    const userId = localStorage.getItem('userId');
    const accessToken = localStorage.getItem('accessToken');
    
    // Avatar customization elements
    const showCustomizeAvatarModalSettingsBtn = document.getElementById('showCustomizeAvatarModalSettings');
    const customizeAvatarModalSettings = document.getElementById('customizeAvatarModalSettings');
    const closeCustomizeAvatarModalSettingsBtn = document.getElementById('closeCustomizeAvatarModalSettings');
    const settingsPreviewImage = document.getElementById('settingsPreviewImage');
    const saveAvatarBtnSettings = document.getElementById('saveAvatarBtnSettings');
    
    // Check if user is logged in
    function updateNavigation() {
      const loggedInNav = document.getElementById('loggedInNav');
      const loggedOutNav = document.getElementById('loggedOutNav');
      
      if (userId && accessToken) {
        loggedInNav.classList.remove('hidden');
        loggedOutNav.classList.add('hidden');
      } else {
        loggedInNav.classList.add('hidden');
        loggedOutNav.classList.remove('hidden');
        window.location.href = '/pages/login.html';
      }
    }

    // Initialize the page when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      // Call updateNavigation on page load
      updateNavigation();
      
      // Load avatar on page load
      loadSidebarUserAvatarOnSettingsPage();

      // Mobile navigation
      const hamburger = document.getElementById('hamburger');
      const sidebar = document.getElementById('sidebar');
      const closeSidebar = document.getElementById('closeSidebar');
      
      if (hamburger && sidebar && closeSidebar) {
        hamburger.addEventListener('click', () => {
          sidebar.classList.toggle('translate-x-0');
        });
        
        closeSidebar.addEventListener('click', () => {
          sidebar.classList.remove('translate-x-0');
        });
      }

      // Topic Management
      const manageTopicsBtn = document.getElementById('manageTopicsBtn');
      if (manageTopicsBtn) {
        manageTopicsBtn.addEventListener('click', () => {
          const topicManagement = document.getElementById('topicManagement');
          topicManagement.classList.toggle('hidden');
          if (!topicManagement.classList.contains('hidden')) {
            loadTopics();
          }
        });
      }

      // Add Topic Button
      const addTopicBtn = document.getElementById('addTopicBtn');
      if (addTopicBtn) {
        addTopicBtn.addEventListener('click', async () => {
          const input = document.getElementById('newTopicInput');
          const topicName = input.value.trim();
          
          if (!topicName) {
            alert('Please enter a topic name');
            return;
          }

          try {
            const response = await fetch('/.netlify/functions/dashboard', {
              method: 'POST',
              body: JSON.stringify({ 
                action: 'addTopic',
                userId,
                topicName 
              }),
              headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
              }
            });

            if (!response.ok) {
              throw new Error('Failed to add topic');
            }

            input.value = ''; // Clear the input
            loadTopics(); // Reload the topics list
            showToast('Topic added successfully!', 'success');
          } catch (error) {
            console.error('Error adding topic:', error);
            showToast('Failed to add topic. Please try again.', 'error');
          }
        });
      }

      // Change Password
      const changePasswordBtn = document.getElementById('changePassword');
      if (changePasswordBtn) {
        changePasswordBtn.addEventListener('click', () => {
          // Will implement password change functionality
          alert('Password change feature coming soon!');
        });
      }

      // Delete Account
      const deleteAccountBtn = document.getElementById('deleteAccount');
      if (deleteAccountBtn) {
        deleteAccountBtn.addEventListener('click', () => {
          if (confirm('Are you sure you want to delete your account? This action cannot be undone.')) {
            // Will implement account deletion functionality
            alert('Account deletion feature coming soon!');
          }
        });
      }

      // Logout
      const logoutBtn = document.getElementById('logout');
      if (logoutBtn) {
        logoutBtn.addEventListener('click', () => {
          localStorage.removeItem('userId');
          localStorage.removeItem('accessToken');
          window.location.href = '/';
        });
      }

      // Initial loads
      loadNotes();
      
      // Load subscription status
      loadSubscriptionStatus();
      
      // Manage subscription button
      const manageSubscriptionBtn = document.getElementById('manageSubscriptionBtn');
      if (manageSubscriptionBtn) {
        manageSubscriptionBtn.addEventListener('click', createPortalSession);
      }
    });

    async function loadTopics() {
      const topicList = document.getElementById('topicList');
      if (!topicList) return;
      
      topicList.innerHTML = '<div class="text-center py-4"><i class="fas fa-spinner fa-spin text-blue-500 text-xl"></i></div>';
      
      try {
        const response = await fetch('/.netlify/functions/dashboard', {
          method: 'POST',
          body: JSON.stringify({
            action: 'getTopics',
            userId
          }),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          }
        });
        
        const result = await response.json();
        
        if (response.ok) {
          if (result.topics && result.topics.length > 0) {
            topicList.innerHTML = '';
            
            result.topics.forEach(topic => {
              const topicItem = document.createElement('div');
              topicItem.className = 'flex justify-between items-center bg-white p-4 rounded-lg shadow-sm mb-2';
              topicItem.dataset.id = topic.id;
              
              topicItem.innerHTML = `
                <div class="topic-name-display">
                  <span class="topic-name font-medium text-gray-800">${topic.name}</span>
                </div>
                <div class="flex items-center gap-2">
                  <button class="edit-topic-btn bg-gray-500 hover:bg-gray-600 text-white px-3 py-1 rounded transition-colors duration-200 text-sm">
                    <i class="fas fa-edit"></i>
                  </button>
                  <button class="delete-topic-btn bg-red-500 hover:bg-red-600 text-white px-3 py-1 rounded transition-colors duration-200 text-sm">
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
              `;
              
              topicList.appendChild(topicItem);
              
              // Edit button
              const editBtn = topicItem.querySelector('.edit-topic-btn');
              editBtn.addEventListener('click', () => {
                const nameDisplay = topicItem.querySelector('.topic-name-display');
                const currentName = topicItem.querySelector('.topic-name').textContent;
                
                // Save button
                saveBtn.addEventListener('click', async () => {
                  const newName = input.value.trim();
                  if (!newName) return;
                  
                  try {
                    const response = await fetch('/.netlify/functions/dashboard', {
                      method: 'POST',
                      body: JSON.stringify({
                        action: 'updateTopic',
                        userId,
                        topicId: topic.id,
                        name: newName
                      }),
                      headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${accessToken}`
                      }
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok) {
                      nameDisplay.innerHTML = `<span class="topic-name font-medium text-gray-800">${newName}</span>`;
                      showToast('Topic updated successfully', 'success');
                    } else {
                      showToast('Failed to update topic: ' + (result.error || 'Unknown error'), 'error');
                    }
                  } catch (error) {
                    console.error('Error updating topic:', error);
                    showToast('Error connecting to server. Please try again.', 'error');
                  }
                });
                
                // Cancel button
                cancelBtn.addEventListener('click', () => {
                  nameDisplay.innerHTML = `<span class="topic-name font-medium text-gray-800">${currentName}</span>`;
                });
              });
              
              // Delete button
              const deleteBtn = topicItem.querySelector('.delete-topic-btn');
              deleteBtn.addEventListener('click', async () => {
                if (!confirm(`Are you sure you want to delete "${topic.name}"?`)) return;
                
                try {
                  const response = await fetch('/.netlify/functions/dashboard', {
                    method: 'POST',
                    body: JSON.stringify({
                      action: 'deleteTopic',
                      userId,
                      topicId: topic.id
                    }),
                    headers: {
                      'Content-Type': 'application/json',
                      'Authorization': `Bearer ${accessToken}`
                    }
                  });
                  
                  const result = await response.json();
                  
                  if (response.ok) {
                    topicItem.remove();
                    showToast('Topic deleted successfully', 'success');
                  } else {
                    showToast('Failed to delete topic: ' + (result.error || 'Unknown error'), 'error');
                  }
                } catch (error) {
                  console.error('Error deleting topic:', error);
                  showToast('Error connecting to server. Please try again.', 'error');
                }
              });
            });
          } else {
            topicList.innerHTML = '<div class="text-center py-4 text-gray-500">No topics found. Add your first topic above.</div>';
          }
        } else {
          topicList.innerHTML = `<div class="text-center py-4 text-red-500">Failed to load topics: ${result.error || 'Unknown error'}</div>`;
        }
      } catch (error) {
        console.error('Error loading topics:', error);
        topicList.innerHTML = '<div class="text-center py-4 text-red-500">Error connecting to server. Please try again.</div>';
      }
    }

    // Helper function to validate email format
    function isValidEmail(email) {
      const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
      return emailRegex.test(email);
    }

    // Notes toggle functionality
    document.addEventListener('DOMContentLoaded', () => {
      // Set up notes toggle functionality
      const notesToggle = document.getElementById('notesToggle');
      const notesPanel = document.getElementById('notesPanel');
      const closeNotes = document.getElementById('closeNotesBtn');
      
      if (notesToggle && notesPanel && closeNotes) {
        notesToggle.addEventListener('click', (e) => {
          e.preventDefault();
          notesPanel.classList.toggle('active');
          if (notesPanel.classList.contains('active')) {
            loadNotesTopics();
            loadNotes();
          }
        });
        
        closeNotes.addEventListener('click', () => {
          notesPanel.classList.toggle('translate-x-full');
          if (!notesPanel.classList.contains('translate-x-full')) {
            loadNotesTopics();
            loadNotes();
          }
        });
      }
      
      // Set up save note functionality
      const saveNoteBtn = document.getElementById('saveNote');
      if (saveNoteBtn) {
        saveNoteBtn.addEventListener('click', saveNote);
      }
      
      // Set up note filter change event
      const noteFilter = document.getElementById('noteFilter');
      if (noteFilter) {
        noteFilter.addEventListener('change', loadNotes);
      }
    });
    
    // Load topics for notes dropdown
    async function loadNotesTopics() {
      const userId = localStorage.getItem('userId');
      const accessToken = localStorage.getItem('accessToken');
      
      try {
        const noteTopicSelect = document.getElementById('noteTopic');
        const noteFilterSelect = document.getElementById('noteFilter');
        
        // Don't overwrite initial options
        const defaultNoteTopicOption = noteTopicSelect.options[0];
        const defaultFilterOptions = Array.from(noteFilterSelect.options).slice(0, 2); // Keep "All" and "Untagged"
        
        // Show loading state
        noteTopicSelect.innerHTML = '';
        noteTopicSelect.appendChild(defaultNoteTopicOption);
        noteTopicSelect.disabled = true;
        
        noteFilterSelect.innerHTML = '';
        defaultFilterOptions.forEach(option => noteFilterSelect.appendChild(option));
        noteFilterSelect.disabled = true;
        
        const response = await fetch('/.netlify/functions/dashboard', {
          method: 'POST',
          body: JSON.stringify({
            action: 'getTopics',
            userId
          }),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          }
        });
        
        const result = await response.json();
        
        // Re-enable selects
        noteTopicSelect.disabled = false;
        noteFilterSelect.disabled = false;
        
        if (response.ok && result.topics && result.topics.length > 0) {
          // Add topics to the note select
          result.topics.forEach(topic => {
            // Add to noteTopic select
            const topicOption = document.createElement('option');
            topicOption.value = topic.id;
            topicOption.textContent = topic.name;
            noteTopicSelect.appendChild(topicOption);
            
            // Add to filter select
            const filterOption = document.createElement('option');
            filterOption.value = topic.id;
            filterOption.textContent = topic.name;
            noteFilterSelect.appendChild(filterOption);
          });
        }
      } catch (error) {
        console.error('Error loading topics for notes:', error);
        showToast('Error loading topics. Please try again.', 'error');
      }
    }
    
    // Load user subscription status
    async function loadSubscriptionStatus() {
      try {
        console.log('Checking subscription status for user:', userId);
        const response = await fetch('/.netlify/functions/check-subscription', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userId,
            accessToken
          }),
        });
        
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Subscription data received:', data);
        
        if (data.error) {
          console.error('Error checking subscription:', data.error);
          document.getElementById('currentPlan').textContent = 'Free Plan';
          document.getElementById('subscriptionDetails').textContent = 'Unable to load subscription details';
          document.getElementById('subscriptionBadge').textContent = 'Free';
          document.getElementById('subscriptionBadge').classList.remove('bg-green-200', 'text-green-800');
          document.getElementById('subscriptionBadge').classList.add('bg-gray-200', 'text-gray-700');
          return;
        }
        
        // Update the subscription UI
        const subscriptionBadge = document.getElementById('subscriptionBadge');
        const currentPlan = document.getElementById('currentPlan');
        const subscriptionDetails = document.getElementById('subscriptionDetails');
        const manageSubscriptionBtn = document.getElementById('manageSubscriptionBtn');
        const upgradePlanBtn = document.getElementById('upgradePlanBtn');
        
        if (data.hasPremium) {
          // Premium user UI
          currentPlan.textContent = 'Premium Plan';
          subscriptionBadge.textContent = 'Premium';
          subscriptionBadge.classList.remove('bg-gray-200', 'text-gray-700');
          subscriptionBadge.classList.add('bg-green-200', 'text-green-800');
          
          // Show the manage button and hide the upgrade button for premium users
          manageSubscriptionBtn.style.display = 'flex';
          upgradePlanBtn.style.display = 'none';
          
          // Set next billing date
          if (data.subscription.currentPeriodEnd) {
            const nextBillingDate = new Date(data.subscription.currentPeriodEnd);
            const formattedDate = nextBillingDate.toLocaleDateString('en-US', { 
              year: 'numeric', 
              month: 'short', 
              day: 'numeric' 
            });
            subscriptionDetails.textContent = `Next billing date: ${formattedDate}`;
          } else {
            subscriptionDetails.textContent = 'Active premium subscription';
          }
          
          // Show trial info if applicable
          if (data.subscription.trialEndDate) {
            const trialEndDate = new Date(data.subscription.trialEndDate);
            if (trialEndDate > new Date()) {
              // Still in trial period
              subscriptionDetails.textContent = `Free trial ends on ${trialEndDate.toLocaleDateString()}`;
            }
          }
          
          // Show cancellation info if applicable
          if (data.subscription.cancelAtPeriodEnd) {
            const endDate = new Date(data.subscription.currentPeriodEnd);
            subscriptionDetails.textContent = `Your subscription will end on ${endDate.toLocaleDateString()}`;
          }
        } else {
          // Free user UI
          currentPlan.textContent = 'Free Plan';
          subscriptionBadge.textContent = 'Free';
          subscriptionBadge.classList.remove('bg-green-200', 'text-green-800');
          subscriptionBadge.classList.add('bg-gray-200', 'text-gray-700');
          
          // Show the upgrade button and hide the manage button for free users
          manageSubscriptionBtn.style.display = 'none';
          upgradePlanBtn.style.display = 'flex';
          upgradePlanBtn.innerHTML = '<i class="fas fa-arrow-up mr-2"></i> Upgrade';
          
          subscriptionDetails.textContent = 'Limited features available';
        }
      } catch (error) {
        console.error('Error loading subscription status:', error);
        document.getElementById('currentPlan').textContent = 'Free Plan';
        document.getElementById('subscriptionDetails').textContent = 'Unable to load subscription details';
        document.getElementById('subscriptionBadge').textContent = 'Free';
        document.getElementById('subscriptionBadge').classList.remove('bg-green-200', 'text-green-800');
        document.getElementById('subscriptionBadge').classList.add('bg-gray-200', 'text-gray-700');
      }
    }
    
    // Create a Stripe customer portal session
    async function createPortalSession() {
      try {
        // Get user details
        const userEmail = localStorage.getItem('userEmail');
        
        // Debug log
        console.log('Creating portal session with:', {
          userId,
          userEmail,
          accessTokenExists: !!accessToken
        });
        
        // Validate required data
        if (!userId || !userEmail) {
          showToast('Missing user information. Please try logging out and back in.', 'error');
          console.error('Missing required user data:', { userId, userEmail });
          return;
        }
        
        const response = await fetch('/.netlify/functions/create-portal-session', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            user: {
              id: userId,
              email: userEmail,
              accessToken
            }
          }),
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('Portal session error:', response.status, errorText);
          showToast(`Error: ${response.status} - Please try again later`, 'error');
          return;
        }
        
        const data = await response.json();
        const { url, error } = data;
        
        if (error) {
          showToast(error, 'error');
          return;
        }
        
        if (!url) {
          showToast('No portal URL returned. Please try again.', 'error');
          console.error('Missing URL in response:', data);
          return;
        }
        
        window.location.href = url;
      } catch (error) {
        console.error('Error creating portal session:', error);
        showToast('An error occurred. Please try again.', 'error');
      }
    }

    // Save a new note
    async function saveNote() {
      const noteText = document.getElementById('noteText').value.trim();
      const topicId = document.getElementById('noteTopic').value;
      const saveButton = document.getElementById('saveNote');
      
      if (!noteText) {
        // Animate textarea to show error
        const textarea = document.getElementById('noteText');
        textarea.classList.add('animate-shake');
        setTimeout(() => textarea.classList.remove('animate-shake'), 500);
        return;
      }
      
      // Show loading state
      const originalButtonText = saveButton.innerHTML;
      saveButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
      saveButton.disabled = true;
      
      const userId = localStorage.getItem('userId');
      const accessToken = localStorage.getItem('accessToken');
      
      try {
        const response = await fetch('/.netlify/functions/dashboard', {
          method: 'POST',
          body: JSON.stringify({
            action: 'saveNote',
            userId,
            content: noteText,
            topicId: topicId || null // Handle untagged case
          }),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          }
        });
        
        const result = await response.json();
        
        if (response.ok) {
          // Show success state
          saveButton.innerHTML = '<i class="fas fa-check"></i> Saved!';
          saveButton.classList.add('success');
          
          // Clear input
          document.getElementById('noteText').value = '';
          
          // Reset button after delay
          setTimeout(() => {
            saveButton.innerHTML = originalButtonText;
            saveButton.classList.remove('success');
            saveButton.disabled = false;
          }, 1500);
          
          // Reload notes list
          loadNotes();
          
          // Show success toast
          showToast('Note saved successfully!', 'success');
        } else {
          // Show error state
          saveButton.innerHTML = originalButtonText;
          saveButton.disabled = false;
          
          showToast('Error saving note: ' + (result.error || 'Unknown error'), 'error');
        }
      } catch (error) {
        console.error('Error saving note:', error);
        saveButton.innerHTML = originalButtonText;
        saveButton.disabled = false;
        showToast('Error connecting to server. Please try again.', 'error');
      }
    }
    
    // Load notes for the notes panel
    async function loadNotes() {
      const userId = localStorage.getItem('userId');
      const accessToken = localStorage.getItem('accessToken');
      const filterValue = document.getElementById('noteFilter').value;
      
      const notesList = document.getElementById('notesList');
      
      // Show loading state
      notesList.innerHTML = `
        <div class="loading-spinner">
          <div class="spinner">
            <div class="spinner-needle"></div>
            <div class="spinner-center"></div>
          </div>
        </div>
      `;
      
      try {
        const response = await fetch('/.netlify/functions/dashboard', {
          method: 'POST',
          body: JSON.stringify({
            action: 'getNotes',
            userId,
            topicId: filterValue === 'all' ? null : (filterValue === 'untagged' ? 'untagged' : filterValue)
          }),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          }
        });
        
        const result = await response.json();
        
        if (response.ok) {
          notesList.innerHTML = '';
          
          if (result.notes && result.notes.length > 0) {
            result.notes.forEach((note, index) => {
              const noteItem = document.createElement('div');
              noteItem.className = 'note-item';
              
              const date = new Date(note.created_at);
              const formattedDate = `${date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}`;
              
              // Add delay for staggered animation effect
              noteItem.style.animationDelay = `${index * 0.05}s`;
              
              noteItem.innerHTML = `
                <div class="note-content">${note.content}</div>
                <div class="note-meta">
                  <div class="note-topic">${note.topic_name || 'Untagged'}</div>
                  <div class="note-date">${formattedDate}</div>
                </div>
                <div class="note-actions">
                  <button class="delete-note" data-note-id="${note.id}">
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
              `;
              
              notesList.appendChild(noteItem);
              
              // Add event listeners for delete buttons
              document.querySelectorAll('.delete-note').forEach(button => {
                button.addEventListener('click', async (e) => {
                  const noteId = e.currentTarget.dataset.noteId;
                  await deleteNote(noteId);
                });
              });
            });
            
            // Show notes list
            notesList.classList.remove('hidden');
          } else {
            notesList.innerHTML = `
              <div class="empty-notes">
                <i class="fas fa-sticky-note"></i>
                <p>No notes found</p>
              </div>
            `;
          }
        } else {
          notesList.innerHTML = `
            <div class="empty-notes">
              <p class="error-message">Failed to load notes: ${result.error || 'Unknown error'}</p>
            </div>
          `;
        }
      } catch (error) {
        console.error('Error loading notes:', error);
        notesList.innerHTML = `
          <div class="empty-notes">
            <p class="error-message">Error connecting to server. Please try again.</p>
          </div>
        `;
      }
    }
    
    // Delete a note
    async function deleteNote(noteId) {
      if (!confirm('Are you sure you want to delete this note?')) return;
      
      const userId = localStorage.getItem('userId');
      const accessToken = localStorage.getItem('accessToken');
      
      try {
        const response = await fetch('/.netlify/functions/dashboard', {
          method: 'POST',
          body: JSON.stringify({
            action: 'deleteNote',
            userId,
            noteId
          }),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          }
        });
        
        const result = await response.json();
        
        if (response.ok) {
          // Reload notes
          loadNotes();
          
          // Show success toast
          showToast('Note deleted successfully', 'success');
        } else {
          showToast('Error deleting note: ' + (result.error || 'Unknown error'), 'error');
        }
      } catch (error) {
        console.error('Error deleting note:', error);
        showToast('Error connecting to server. Please try again.', 'error');
      }
    }
    
    // --- BEGIN AVATAR CUSTOMIZATION FOR SETTINGS PAGE ---
    async function loadSidebarUserAvatarOnSettingsPage() {
      const userId = localStorage.getItem('userId');
      const accessToken = localStorage.getItem('accessToken');
      const settingsSidebarUserAvatar = document.getElementById('settingsSidebarUserAvatar');
      const settingsAvatarLoading = document.getElementById('settingsAvatarLoading');
      
      // Check for cached avatar URL first
      const cachedAvatarUrl = localStorage.getItem('userAvatarUrl');

      if (!userId || !accessToken) {
        console.warn('User not authenticated, cannot load avatar for settings sidebar.');
        showDefaultAvatar(settingsSidebarUserAvatar, settingsAvatarLoading);
        return;
      }

      if (!settingsSidebarUserAvatar) {
        console.error('Settings sidebar avatar image element not found.');
        return;
      }
      
      // Use cached avatar if available (prevents flashing)
      if (cachedAvatarUrl) {
        settingsSidebarUserAvatar.src = cachedAvatarUrl;
        settingsSidebarUserAvatar.onload = () => {
          settingsSidebarUserAvatar.classList.remove('opacity-0');
          settingsSidebarUserAvatar.classList.add('opacity-100');
          if (settingsAvatarLoading) settingsAvatarLoading.style.display = 'none';
        };
      }

      try {
        const response = await fetch('/.netlify/functions/dashboard', {
          method: 'POST',
          body: JSON.stringify({
            action: 'getAvatar',
            userId: userId
          }),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          }
        });
        const result = await response.json();
        if (response.ok && result.avatarUrl) {
          // Cache the avatar URL
          localStorage.setItem('userAvatarUrl', result.avatarUrl);
          
          // If URL is different from cached version, update the display
          if (settingsSidebarUserAvatar.src !== result.avatarUrl) {
            settingsSidebarUserAvatar.src = result.avatarUrl;
            settingsSidebarUserAvatar.onload = () => {
              settingsSidebarUserAvatar.classList.remove('opacity-0');
              settingsSidebarUserAvatar.classList.add('opacity-100');
              if (settingsAvatarLoading) settingsAvatarLoading.style.display = 'none';
            };
          } else if (settingsSidebarUserAvatar.classList.contains('opacity-0')) {
            // In case the image was already loaded but not made visible
            settingsSidebarUserAvatar.classList.remove('opacity-0');
            settingsSidebarUserAvatar.classList.add('opacity-100');
            if (settingsAvatarLoading) settingsAvatarLoading.style.display = 'none';
          }
        } else {
          console.error('Failed to load avatar for settings sidebar:', result.error);
          // Only show default if there's no cached avatar already displayed
          if (!cachedAvatarUrl) {
            showDefaultAvatar(settingsSidebarUserAvatar, settingsAvatarLoading);
          }
        }
      } catch (error) {
        console.error('Error loading avatar for settings sidebar:', error);
        // Only show default if there's no cached avatar already displayed
        if (!cachedAvatarUrl) {
          showDefaultAvatar(settingsSidebarUserAvatar, settingsAvatarLoading);
        }
      }
    }

    // Helper function to display default avatar
    function showDefaultAvatar(imgElement, loadingElement) {
      if (!imgElement) return;
      
      imgElement.src = '../assets/avatars/default.png';
      imgElement.onload = () => {
        imgElement.classList.remove('opacity-0');
        imgElement.classList.add('opacity-100');
        if (loadingElement) loadingElement.style.display = 'none';
      };
    }

    function loadAvatarIntoModalPreview() {
      const settingsSidebarUserAvatar = document.getElementById('settingsSidebarUserAvatar');
      const settingsPreviewImage = document.getElementById('settingsPreviewImage');
      
      if (!settingsSidebarUserAvatar) {
        console.error('Sidebar avatar element not found');
        return;
      }
      
      if (!settingsPreviewImage) {
        console.error('Preview image element not found');
        return;
      }
      
      settingsPreviewImage.src = settingsSidebarUserAvatar.src;
      const currentAvatarFileName = settingsSidebarUserAvatar.src.split('/').pop();
      const currentAvatarId = currentAvatarFileName ? currentAvatarFileName.split('.')[0] : 'default';
      settingsPreviewImage.dataset.avatarId = currentAvatarId;
      
      console.log('Loaded current avatar into preview:', currentAvatarId);
      
      // Reset any selected state
      const allAvatars = document.querySelectorAll('.avatar-option');
      allAvatars.forEach(avatar => {
        avatar.classList.remove('border-blue-500');
        avatar.classList.add('border-transparent');
        
        // Highlight the currently active avatar
        if (avatar.dataset.avatarId === currentAvatarId) {
          avatar.classList.remove('border-transparent');
          avatar.classList.add('border-blue-500');
        }
      });
    }

    // Window-level function to update the preview image
    window.updateSettingsPreview = function(imgElement) {
      const settingsPreviewImage = document.getElementById('settingsPreviewImage');
      if (settingsPreviewImage) {
        settingsPreviewImage.src = imgElement.src;
        settingsPreviewImage.dataset.avatarId = imgElement.dataset.avatarId;
        console.log('Avatar preview updated to:', imgElement.dataset.avatarId);
        
        // Add visual indicator for selection
        const allAvatars = document.querySelectorAll('.avatar-option');
        allAvatars.forEach(avatar => {
          avatar.classList.remove('border-blue-500');
          avatar.classList.add('border-transparent');
        });
        imgElement.classList.remove('border-transparent');
        imgElement.classList.add('border-blue-500');
      } else {
        console.error("Settings preview image element not found.");
      }
    }

    async function saveSettingsAvatar() {
      // Get the selected avatar
      const selectedAvatar = document.querySelector('.avatar-option.selected');
      if (!selectedAvatar) {
        showToast('Please select an avatar', 'error');
        return;
      }

      const avatarId = selectedAvatar.dataset.avatarId;
      
      // Get the user ID and access token from localStorage
      const userId = localStorage.getItem('userId');
      const accessToken = localStorage.getItem('accessToken');
      
      if (!userId || !accessToken) {
        showToast('You must be logged in to set an avatar', 'error');
        return;
      }

      // Show loading state
      const saveButton = document.querySelector('#saveAvatarBtnSettings');
      const originalText = saveButton.textContent;
      saveButton.textContent = 'Saving...';
      saveButton.disabled = true;
      
      try {
        // Send the avatarId to the server to save in the database
        const response = await fetch('/.netlify/functions/dashboard', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${accessToken}`
          },
          body: JSON.stringify({
            action: 'updateAvatar',
            userId: userId,
            avatarId: avatarId
          })
        });

        const result = await response.json();
        
        if (!response.ok) {
          throw new Error(result.error || 'Failed to update avatar');
        }
        
        console.log('Avatar saved to database:', avatarId);
        
        // Update the sidebar avatar with the URL returned from the server
        const settingsSidebarUserAvatar = document.getElementById('settingsSidebarUserAvatar');
        if (settingsSidebarUserAvatar && result.avatarUrl) {
          settingsSidebarUserAvatar.src = result.avatarUrl;
        }

        // Close the modal
        const customizeAvatarModalSettings = document.getElementById('customizeAvatarModalSettings');
        customizeAvatarModalSettings.classList.add('hidden');
        document.body.style.overflow = '';
        
        showToast('Avatar updated successfully!', 'success');
      } catch (error) {
        console.error('Error saving avatar:', error);
        showToast(`Failed to update avatar. Details: ${error.message || 'Unknown error'}`, 'error');
      } finally {
        // Reset button state
        saveButton.textContent = originalText;
        saveButton.disabled = false;
      }
    }

    // Function to handle avatar selection in the modal
    function setupAvatarSelection() {
      const avatarOptions = document.querySelectorAll('.avatar-option');
      
      avatarOptions.forEach(option => {
        option.addEventListener('click', function() {
          // Remove selected class from all options
          avatarOptions.forEach(opt => opt.classList.remove('selected', 'border-blue-500', 'border-2'));
          
          // Add selected class to clicked option
          this.classList.add('selected', 'border-blue-500', 'border-2');
          
          // Update preview image
          const avatarImg = this.querySelector('img');
          const previewImg = document.getElementById('settingsPreviewImage');
          if (avatarImg && previewImg) {
            previewImg.src = avatarImg.src;
          }
        });
      });
    }

    // Initialize all event listeners after DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, setting up avatar customization');
      setupAvatarSelection();
      
      // Button to open the customization modal
      const showCustomizeAvatarModalSettingsBtn = document.getElementById('showCustomizeAvatarModalSettings');
      const customizeAvatarModalSettings = document.getElementById('customizeAvatarModalSettings');
      
      if (showCustomizeAvatarModalSettingsBtn && customizeAvatarModalSettings) {
        showCustomizeAvatarModalSettingsBtn.addEventListener('click', function() {
          console.log('Opening avatar customization modal');
          loadAvatarIntoModalPreview();
          customizeAvatarModalSettings.classList.remove('hidden');
          document.body.style.overflow = 'hidden';
        });
      } else {
        console.error('Customize button or modal not found', {
          button: showCustomizeAvatarModalSettingsBtn,
          modal: customizeAvatarModalSettings
        });
      }
      
      // Save button in the modal
      const saveAvatarBtnSettings = document.getElementById('saveAvatarBtnSettings');
      if (saveAvatarBtnSettings) {
        saveAvatarBtnSettings.addEventListener('click', function() {
          console.log('Save avatar button clicked');
          saveSettingsAvatar();
        });
      } else {
        console.error('Save avatar button not found');
      }
      
      // Close button for modal
      const closeCustomizeAvatarModalSettingsBtn = document.getElementById('closeCustomizeAvatarModalSettings');
      if (closeCustomizeAvatarModalSettingsBtn) {
        closeCustomizeAvatarModalSettingsBtn.addEventListener('click', () => {
          console.log('Close avatar modal button clicked');
          customizeAvatarModalSettings.classList.add('hidden');
          document.body.style.overflow = '';
        });
      } else {
        console.error('Close button not found');
      }
      
      // Allow clicking outside modal to close it
      window.addEventListener('click', (event) => {
        if (event.target === customizeAvatarModalSettings) {
          console.log('Clicked outside modal, closing');
          customizeAvatarModalSettings.classList.add('hidden');
          document.body.style.overflow = '';
        }
      });
    });

    // Close button and overlay click handlers are set in the DOM ready event listener
    // --- END AVATAR CUSTOMIZATION FOR SETTINGS PAGE ---
  </script>

  <!-- Notes Panel -->
  <div id="notesPanel" class="fixed top-0 right-0 w-96 h-screen bg-white shadow-lg z-50 flex flex-col border-l border-gray-200 transform translate-x-full transition-transform duration-300 ease-in-out">
    <div class="flex justify-between items-center p-5 bg-gray-50 border-b border-gray-200">
      <h2 class="text-xl font-semibold text-gray-800 flex items-center gap-2">
        <i class="fas fa-sticky-note text-yellow-400"></i> Quick Notes
      </h2>
      <button class="text-2xl text-gray-500 hover:text-gray-700 transition-colors" id="closeNotesBtn">&times;</button>
    </div>
    
    <div class="flex-1 flex flex-col overflow-hidden">
      <div class="p-5 border-b border-gray-200">
        <textarea id="noteText" placeholder="Jot down a thought..." class="w-full h-24 p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-yellow-400 focus:border-transparent resize-none transition-all duration-200 font-eb-garamond"></textarea>
        <div class="flex gap-3 mt-4">
          <select id="noteTopic" class="flex-1 p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-yellow-400 focus:border-transparent text-sm">
            <option value="">Untagged</option>
            <!-- Topics will be loaded here -->
          </select>
          <button id="saveNote" class="bg-yellow-400 hover:bg-yellow-500 text-gray-800 px-4 py-2 rounded-lg transition-colors duration-200 flex items-center gap-2">
            <i class="fas fa-save"></i> Save
          </button>
        </div>
      </div>
      
      <div class="flex justify-between items-center p-4 border-b border-gray-200">
        <h3 class="font-medium text-gray-800">Saved Notes</h3>
        <select id="noteFilter" class="p-1.5 text-sm border border-gray-300 rounded-lg">
          <option value="all">All Notes</option>
          <option value="untagged">Untagged</option>
          <!-- Topics will be loaded here -->
        </select>
      </div>
      
      <div id="notesList" class="flex-1 overflow-y-auto p-4">
        <!-- Notes will be loaded here -->
      </div>
    </div>
  </div>
  <!-- Customize Avatar Modal -->
  <div id="customizeAvatarModalSettings" class="modal fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-40 hidden">
    <div class="modal-content bg-white p-6 rounded-lg shadow-lg max-w-lg w-full relative">
      <button id="closeCustomizeAvatarModalSettings" class="absolute top-3 right-3 text-2xl text-gray-500 hover:text-gray-700">&times;</button>
      <h2 class="text-2xl font-bold mb-4">Customize Your Tutor Avatar</h2>
      <p class="text-gray-600 mb-4">Make your Koda Tutor one-of-a-kind!</p>
      <div class="flex flex-col md:flex-row gap-6">
        <div class="flex-1">
          <h3 class="text-lg font-semibold mb-2">Preview</h3>
          <div id="avatarPreviewSettings" class="w-32 h-32 rounded-full bg-gray-200 flex items-center justify-center mx-auto" style="background-size: cover; background-position: center;">
            <img id="settingsPreviewImage" src="../assets/avatars/default.png" alt="Avatar Preview" class="w-full h-full rounded-full object-cover">
          </div>
        </div>
        <div class="flex-1">
          <div class="avatar-options flex flex-wrap gap-4 justify-center mt-4">
            <div class="avatar-option cursor-pointer rounded-full p-1" data-avatar-id="2">
              <img src="../assets/avatars/zara.png" alt="Zara Avatar" class="w-16 h-16 rounded-full">
            </div>
            <div class="avatar-option cursor-pointer rounded-full p-1" data-avatar-id="4">
              <img src="../assets/avatars/max.png" alt="Max Avatar" class="w-16 h-16 rounded-full">
            </div>
            <div class="avatar-option cursor-pointer rounded-full p-1" data-avatar-id="3">
              <img src="../assets/avatars/luna.png" alt="Luna Avatar" class="w-16 h-16 rounded-full">
            </div>
            <div class="avatar-option cursor-pointer rounded-full p-1" data-avatar-id="1">
              <img src="../assets/avatars/default.png" alt="Default Avatar" class="w-16 h-16 rounded-full">
            </div>
          </div>
          <button id="saveAvatarBtnSettings" class="w-full bg-blue-500 text-white py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors duration-200">Save Avatar</button>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    // Improved Toast Notification Function
    function showToast(message, type = 'info') {
      console.log(`Toast [${type}]: ${message}`);
      
      const toastContainer = document.getElementById('toastContainer');
      console.log('Toast container:', toastContainer);
      
      if (!toastContainer) {
        console.error('Toast container not found');
        return;
      }
      
      // Create toast element
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      
      // Icons based on type
      let icon;
      switch(type) {
        case 'success':
          icon = '<i class="fas fa-check-circle"></i>';
          break;
        case 'error':
          icon = '<i class="fas fa-exclamation-circle"></i>';
          break;
        default:
          icon = '<i class="fas fa-info-circle"></i>';
      }
      
      toast.innerHTML = `
        <div class="toast-content">
          ${icon}
          <span>${message}</span>
        </div>
        <button class="toast-close-btn">&times;</button>
      `;
      
      // Add to container
      toastContainer.appendChild(toast);
      
      // Force browser reflow to ensure transition works
      toast.offsetHeight;
      
      // Add active class after a brief delay to trigger the animation
      setTimeout(() => {
        toast.classList.add('active');
      }, 10);
      
      // Add event listener to close button
      const closeBtn = toast.querySelector('.toast-close-btn');
      closeBtn.addEventListener('click', () => {
        closeToast(toast);
      });
      
      // Auto close after 4 seconds
      const timeoutId = setTimeout(() => {
        closeToast(toast);
      }, 4000);
      
      // Store timeout ID to clear if manually closed
      toast.dataset.timeoutId = timeoutId;
      
      function closeToast(toastElement) {
        // Clear timeout if exists
        const timeoutId = toastElement.dataset.timeoutId;
        if (timeoutId) clearTimeout(parseInt(timeoutId));
        
        // Add closing animation
        toastElement.classList.remove('active');
        toastElement.classList.add('toast-closing');
        
        // Remove after animation completes
        setTimeout(() => {
          toastElement.remove();
        }, 300);
      }
    }
  </script>
</body>
</html>