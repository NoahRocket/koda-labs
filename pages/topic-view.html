<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Topic View - Koda Tutor</title>
  <link rel="stylesheet" href="../styles/main.css">
  <link rel="stylesheet" href="../styles/navbar.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    /* body is styled by Tailwind classes */
    .topic-header-container {
      display: flex;
      align-items: center;
      padding: 1rem 1.5rem;
      background-color: #fff;
      border-bottom: 1px solid #e5e7eb;
      /* Add top margin on mobile to clear the hamburger menu */
      margin-top: 2.5rem;
      /* position: sticky; top: 0; z-index: 30; /* Optional: if you want a sticky header */
    }

    /* Adjust spacing for larger screens where hamburger isn't shown */
    @media (min-width: 768px) { /* md breakpoint */
      .topic-header-container {
        margin-top: 0;
      }
    }
    .back-arrow {
      font-size: 1.5rem;
      color: #374151;
      margin-right: 1rem;
      text-decoration: none;
    }
    .back-arrow:hover {
      color: #00A3E0;
    }
    .topic-title-h1 {
      font-size: 1.75rem;
      font-weight: 600;
      color: #1f2937;
      line-height: 1.2;
      display: flex;
      align-items: center;
    }
    
    .emoji {
      font-size: 1.5rem;
      margin-right: 0.5rem;
    }
    .tab-container-main {
      padding: 0 1.5rem 1.5rem; /* Added bottom padding */
      flex-grow: 1; /* Allows this container to grow and fill space */
      overflow-y: auto; /* Allows content within tabs to scroll if it overflows */
    }
    .tab-buttons button {
      padding: 0.75rem 1.25rem;
      margin-right: 0.5rem;
      border: none;
      background-color: transparent;
      color: #6b7280;
      font-weight: 500;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: color 0.2s ease, border-color 0.2s ease;
    }
    .tab-buttons button.active {
      color: #00A3E0;
      border-bottom-color: #00A3E0;
    }
    .tab-content {
      margin-top: 1rem;
      padding: 1.5rem;
      background-color: #fff;
      border-radius: 0.5rem;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .tab-pane {
      display: none;
    }
    .tab-pane.active {
      display: block;
    }
    .conversation-item, .bookmark-item, .note-item {
        background-color: #f9fafb;
        border: 1px solid #e5e7eb;
        border-radius: 0.375rem;
        padding: 1rem;
        margin-bottom: 0.75rem;
        box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
    }
    .item-meta {
        font-size: 0.875rem;
        color: #6b7280;
        margin-bottom: 0.5rem;
    }
    .item-content p, .item-content div {
        color: #1f2937;
        line-height: 1.6;
        word-break: break-word; /* Helps with long strings */
    }
    .message {
        padding: 0.5rem;
        margin-bottom: 0.25rem;
        border-radius: 0.375rem;
        max-width: 85%;
    }
    .user-message {
        background-color: #EFF6FF; /* Tailwind blue-50 */
        color: #1E40AF; /* Tailwind blue-800 */
        align-self: flex-end;
        margin-left: auto; /* Push to right */
    }
    .ai-message {
        background-color: #F3F4F6; /* Tailwind gray-100 */
        color: #1F2937; /* Tailwind gray-800 */
        align-self: flex-start;
    }
    .loading-spinner-container {
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 150px; /* Give some space for spinner */
    }
    /* Toast styling */
    .toast-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 9999;
      max-width: 300px;
    }
    
    .toast {
      margin-bottom: 10px;
      padding: 12px;
      border-radius: 4px;
      color: white;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      opacity: 0;
      transform: translateY(-20px);
      transition: opacity 0.3s, transform 0.3s;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .toast.active {
      opacity: 1;
      transform: translateY(0);
    }
    
    .toast.toast-closing {
      opacity: 0;
      transform: translateY(-20px);
    }
    
    .toast.success {
      background-color: #4caf50;
    }
    
    .toast.error {
      background-color: #f44336;
    }
    
    .toast.info {
      background-color: #2196f3;
    }
    
    .toast-content {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .toast-close-btn {
      background: none;
      border: none;
      color: white;
      cursor: pointer;
      font-size: 18px;
      padding: 0;
    }
  </style>
</head>
<body class="bg-gray-50 font-eb-garamond min-h-screen flex text-gray-900" style="background: linear-gradient(180deg, #F7F7F7 0%, #FFFFFF 100%);">
  <!-- Toast Container -->
  <div id="toastContainer" class="toast-container"></div>

  <!-- Mobile Hamburger -->
  <div class="md:hidden fixed top-4 left-4 z-50 cursor-pointer p-2 mobile-touch-target" id="hamburger">
    <div class="w-6 h-0.5 bg-gray-800 mb-1"></div>
    <div class="w-6 h-0.5 bg-gray-800 mb-1"></div>
    <div class="w-6 h-0.5 bg-gray-800"></div>
  </div>

  <!-- Sidebar Navigation -->
  <div id="sidebar" class="fixed top-0 left-0 h-screen w-64 app-sidebar transform -translate-x-full md:translate-x-0 transition-transform duration-300 z-40">
    <div class="flex flex-col h-full">
      <div class="logo-container pt-12 md:pt-5">
        <h1 class="app-logo">Koda <span>Tutor</span></h1>
        <button id="closeSidebar" class="absolute top-5 right-4 text-gray-300 hover:text-white md:hidden mobile-touch-target">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="p-4 flex justify-center border-b border-gray-700">
        <div class="w-10 h-10 rounded-full bg-gray-600 flex items-center justify-center overflow-hidden" id="avatarContainer">
          <img id="userAvatarSidebar" src="" alt="User Avatar" class="w-full h-full object-cover opacity-0 transition-opacity duration-300">
          <div id="avatarLoading" class="absolute">
            <i class="fas fa-circle-notch fa-spin text-gray-400"></i>
          </div>
        </div>
      </div>
      <nav class="flex-1 overflow-y-auto py-4">
        <ul class="space-y-1 px-4">
        <li id="loggedInNav" class="hidden flex-col space-y-1">
          <a href="dashboard.html" class="nav-link">
            <i class="fas fa-compass"></i>
            <span class="mobile-readable">Dashboard</span>
          </a>
          <a href="chat.html" class="nav-link">
            <i class="fas fa-comments"></i>
            <span class="mobile-readable">Chat</span>
          </a>

          <a href="podcasts.html" class="nav-link">
            <i class="fas fa-podcast"></i>
            <span class="mobile-readable">Podcasts</span>
          </a>
          <a href="settings.html" class="nav-link">
            <i class="fas fa-cog"></i>
            <span class="mobile-readable">Settings</span>
          </a>
        </li>
        <li id="loggedOutNav" class="hidden flex-col space-y-1">
          <a href="login.html" class="nav-link">
            <i class="fas fa-sign-in-alt"></i>
            <span>Login</span>
          </a>
          <a href="signup.html" class="nav-link">
            <i class="fas fa-user-plus"></i>
            <span>Sign Up</span>
          </a>
        </li>
        </ul>
      </nav>
      <div class="p-4 border-t border-gray-700">
        <button id="logout" class="logout-btn w-full">
          <i class="fas fa-sign-out-alt"></i>
          <span>Logout</span>
        </button>
      </div>
    </div>
  </div>

  <!-- Main Content Area -->
  <div class="md:ml-64 flex-1 min-h-screen flex flex-col">
    <div class="topic-header-container">
      <a href="dashboard.html" class="back-arrow" aria-label="Back to Dashboard">
        <i class="fas fa-arrow-left"></i>
      </a>
      <h1 id="topicTitle" class="topic-title-h1">
        <span id="topicEmoji" class="emoji mr-2">ðŸ“š</span>
        <span id="topicName">Loading Topic...</span>
      </h1>
    </div>

    <div class="tab-container-main">
      <div class="tab-buttons border-b border-gray-200 mb-4">
        <button class="tab-btn active" data-tab="keyConcepts">Key Concepts</button>
        <button class="tab-btn" data-tab="bookmarks">Bookmarks</button>
        <button class="tab-btn" data-tab="notes">Notes</button>
        <button class="tab-btn" data-tab="videos">Videos</button>
        <button class="tab-btn" data-tab="conversations">Conversations</button>
      </div>

      <div id="keyConceptsTab" class="tab-pane active tab-content">
        <div id="keyConceptsSpinner" class="loading-spinner-container d-none"><i class="fas fa-spinner fa-spin fa-2x text-gray-400"></i></div>
        <div id="keyConceptsContentPlaceholder"></div> <!-- Placeholder for key concepts text -->
        <button id="generateKeyConceptsBtn" class="mt-4 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50">Generate Key Concepts</button>
        <div id="keyConceptsStatus" class="mt-2 text-sm text-gray-600"></div>
      </div>
      <div id="bookmarksTab" class="tab-pane tab-content">
            <!-- Add Bookmark Form -->
            <div class="bg-gray-50 rounded-lg shadow-md p-6 mb-8" style="background-color: #F7F7F7;">
              <h2 class="text-xl font-semibold text-gray-800 mb-4">Add New Bookmark</h2>
              <form id="addBookmarkFormTopicView" class="space-y-4">
                <div>
                  <label for="topicViewBookmarkUrl" class="block text-sm font-medium text-gray-700 mb-1">URL</label>
                  <input 
                    type="url" 
                    id="topicViewBookmarkUrl" 
                    placeholder="https://example.com" 
                    required 
                    class="w-full p-3 border border-gray-300 rounded-lg transition-all duration-200 focus:ring-blue-500 focus:border-blue-500"
                  >
                </div>
                <button 
                  type="submit" 
                  class="w-full add-bookmark-btn text-white py-3 px-6 rounded-lg transition-all flex items-center justify-center gap-2 bg-blue-500 hover:bg-blue-600"
                >
                  <i class="fas fa-plus"></i>
                  Add Bookmark
                </button>
              </form>
            </div>
            <!-- Bookmarks List -->
            <div id="topicViewBookmarksList" class="space-y-4 mt-6">
              <!-- Bookmarks will be loaded here by renderBookmarks -->
            </div>
          </div>
      <div id="notesTab" class="tab-pane tab-content">
        <!-- Add New Note Form -->
        <div class="bg-gray-50 rounded-lg shadow-md p-6 mb-8" style="background-color: #F7F7F7;">
          <h2 class="text-xl font-semibold text-gray-800 mb-4">Add New Note</h2>
          <form id="addNoteFormTopicView" class="space-y-4">
            <div>
              <label for="topicViewNoteContent" class="block text-sm font-medium text-gray-700 mb-1">Note</label>
              <textarea id="topicViewNoteContent" rows="4" placeholder="Write your note here..." class="w-full border-gray-300 rounded-md p-2"></textarea>
            </div>
            <button type="submit" class="w-full add-note-btn text-white py-3 px-6 rounded-lg transition-all flex items-center justify-center gap-2 bg-blue-500 hover:bg-blue-600">
              <i class="fas fa-plus"></i>
              Add Note
            </button>
          </form>
        </div>
        <!-- Notes List -->
        <div id="topicViewNotesList" class="space-y-4 mt-6">
          <!-- Notes will be loaded here by renderNotes -->
        </div>
      </div>
      <div id="videosTab" class="tab-pane tab-content">
        <div class="loading-spinner-container"><i class="fas fa-spinner fa-spin fa-2x text-gray-400"></i></div>
      </div>
      <div id="conversationsTab" class="tab-pane tab-content">
        <div class="loading-spinner-container"><i class="fas fa-spinner fa-spin fa-2x text-gray-400"></i></div>
      </div>
    </div>
  </div>

  <script src="../scripts/utils.js"></script> 
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Navbar interactivity
      const hamburger = document.getElementById('hamburger');
      const sidebar = document.getElementById('sidebar');
      const closeSidebarBtn = document.getElementById('closeSidebar');
      if (hamburger && sidebar && closeSidebarBtn) {
        hamburger.addEventListener('click', () => sidebar.classList.toggle('-translate-x-full'));
        closeSidebarBtn.addEventListener('click', () => sidebar.classList.add('-translate-x-full'));
      }
      const logoutBtn = document.getElementById('logout');
      if (logoutBtn) {
        logoutBtn.addEventListener('click', () => {
          localStorage.removeItem('userId');
          localStorage.removeItem('accessToken');
          localStorage.removeItem('userAvatarUrl');
          window.location.href = '/'; 
        });
      }
      checkAuth('../'); // Check auth status and update nav links
      updateNavigation('../'); // Update nav links visibility
    // loadUserSession(); // Make sure this is defined and works - Function not found in utils.js
      loadTutorAvatarInternal(); // Load avatar for sidebar

      // Attach event listener to bookmark form
      const addBookmarkFormTV = document.getElementById('addBookmarkFormTopicView');
      if (addBookmarkFormTV) {
        addBookmarkFormTV.addEventListener('submit', handleAddBookmarkTopicView);
        console.log('Event listener attached to bookmark form');
      } else {
        console.error('Bookmark form not found in DOM!');
      }

      // Attach event listener to note form
      const addNoteFormTV = document.getElementById('addNoteFormTopicView');
      if (addNoteFormTV) {
        addNoteFormTV.addEventListener('submit', handleAddNoteTopicView);
        console.log('Event listener attached to note form');
      } else {
        console.error('Note form not found in DOM!');
      }

      // Topic View specific elements
      const topicTitleElement = document.getElementById('topicTitle');
      const conversationsTabEl = document.getElementById('conversationsTab');
      const bookmarksTabEl = document.getElementById('bookmarksTab');
      const notesTabEl = document.getElementById('notesTab');
      const keyConceptsContentPlaceholder = document.getElementById('keyConceptsContentPlaceholder');
      const generateKeyConceptsBtn = document.getElementById('generateKeyConceptsBtn');
      const keyConceptsStatusEl = document.getElementById('keyConceptsStatus'); // This might become redundant or be removed later

    // --- Toast Notification Function ---
    function showToast(message, type = 'info', duration = 4000) {
      const container = document.getElementById('toastContainer');
      if (!container) return;

      const toast = document.createElement('div');
      toast.className = `toast ${type}`;

      const content = document.createElement('div');
      content.className = 'toast-content';
      
      let iconClass = '';
      if (type === 'success') iconClass = 'fas fa-check-circle';
      else if (type === 'error') iconClass = 'fas fa-times-circle';
      else if (type === 'info') iconClass = 'fas fa-info-circle';

      if (iconClass) {
        const icon = document.createElement('i');
        icon.className = iconClass;
        content.appendChild(icon);
      }

      const messageSpan = document.createElement('span');
      messageSpan.textContent = message;
      content.appendChild(messageSpan);
      toast.appendChild(content);

      const closeButton = document.createElement('button');
      closeButton.className = 'toast-close-btn';
      closeButton.innerHTML = '&times;';
      closeButton.onclick = () => {
        toast.classList.add('toast-closing');
        toast.addEventListener('transitionend', () => toast.remove());
      };
      toast.appendChild(closeButton);

      container.appendChild(toast);

      // Animate in
      requestAnimationFrame(() => {
        toast.classList.add('active');
      });

      // Auto-dismiss
      setTimeout(() => {
        toast.classList.add('toast-closing');
        toast.addEventListener('transitionend', () => toast.remove(), { once: true });
      }, duration);
    }
    // --- End Toast Notification Function ---
      const keyConceptsSpinner = document.getElementById('keyConceptsSpinner');
      // keyConceptsContentPlaceholder is already declared above, removing duplicate.
      const videosTabEl = document.getElementById('videosTab');

      const urlParams = new URLSearchParams(window.location.search);
      const topicId = urlParams.get('topicId');
      const CACHE_TTL_MS = 1000 * 60 * 10; // 10-minute cache TTL

      // --- START BOOKMARK FUNCTIONS FOR TOPIC VIEW ---
      function escapeHTML(str) {
        if (str === null || str === undefined) return '';
        return String(str).replace(/[&<>"']/g, function (match) {
          return {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;'
          }[match];
        });
      }

      async function handleAddBookmarkTopicView(event) {
        event.preventDefault();
        const userId = localStorage.getItem('userId');
        const accessToken = localStorage.getItem('accessToken');
        const urlParams = new URLSearchParams(window.location.search);
        const topicId = urlParams.get('topicId');

        const urlInput = document.getElementById('topicViewBookmarkUrl');
        const bookmarkUrl = urlInput.value.trim();

        if (!bookmarkUrl) {
          showToast('Please enter a valid URL.', 'error');
          return;
        }
        if (!topicId) {
          showToast('Error: Topic ID is missing.', 'error');
          return;
        }
        if (!userId || !accessToken) {
          showToast('Authentication error. Please log in.', 'error');
          return;
        }

        const submitButton = this.querySelector('button[type="submit"]');
        const originalButtonText = submitButton.innerHTML;
        submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Adding...';
        submitButton.disabled = true;

        try {
          const response = await fetch('/.netlify/functions/dashboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
            body: JSON.stringify({
              action: 'addBookmark',
              topicId,
              bookmarkUrl
            }),
          });
          const result = await response.json();
          if (response.ok) {
            showToast('Bookmark added successfully!', 'success');
            urlInput.value = ''; // Clear input
            fetchTopicDetails(); // Refresh topic details, which includes bookmarks
          } else {
            showToast(result.error || 'Failed to add bookmark.', 'error');
          }
        } catch (error) {
          console.error('Error adding bookmark:', error);
          showToast('An error occurred while adding the bookmark.', 'error');
        } finally {
          submitButton.innerHTML = originalButtonText;
          submitButton.disabled = false;
        }
      }

      async function handleDeleteBookmarkTopicView(event) {
        const userId = localStorage.getItem('userId');
        const accessToken = localStorage.getItem('accessToken');
        const bookmarkId = event.currentTarget.dataset.id;

        if (!confirm('Are you sure you want to delete this bookmark?')) {
          return;
        }
        if (!userId || !accessToken) {
          showToast('Authentication error. Please log in.', 'error');
          return;
        }
        
        try {
          const response = await fetch('/.netlify/functions/dashboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
            body: JSON.stringify({
              action: 'deleteBookmark',
              bookmarkId
            }),
          });
          const result = await response.json();
          if (response.ok) {
            showToast('Bookmark deleted successfully.', 'success');
            fetchTopicDetails(); // Refresh topic details
          } else {
            showToast(result.error || 'Failed to delete bookmark.', 'error');
          }
        } catch (error) {
          console.error('Error deleting bookmark:', error);
          showToast('An error occurred while deleting the bookmark.', 'error');
        }
      }
      // --- END BOOKMARK FUNCTIONS FOR TOPIC VIEW ---

      async function fetchTopicDetailsCached() {
        const cacheKey = `topicDetails_${topicId}`;
        const raw = localStorage.getItem(cacheKey);
        if (raw) {
          try {
            const { timestamp, data } = JSON.parse(raw);
            if (Date.now() - timestamp < CACHE_TTL_MS) {
              // Render cached immediately
              document.getElementById('topicName').textContent = (data.topic && data.topic.name) ? data.topic.name : 'Topic Details';
              document.getElementById('topicEmoji').textContent = (data.topic && data.topic.emoji) ? data.topic.emoji : 'ðŸ“š';
              renderConversations(data.conversations || []);
              renderBookmarks(data.bookmarks || []);
              renderNotes(data.notes || []);
              renderKeyConcepts(data.keyConcepts || null);
              // Background refresh
              fetchTopicDetails();
              return;
            }
          } catch {}
        }
        await fetchTopicDetails(); // fallback to server
      }

      if (!topicId) {
        topicTitleElement.textContent = 'Error: Topic ID not found.';
        conversationsTabEl.innerHTML = '<p>No topic ID provided in the URL.</p>';
        return;
      }

      // Tab switching logic
      const tabButtons = document.querySelectorAll('.tab-btn');
      const tabPanes = document.querySelectorAll('.tab-pane');
      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          tabButtons.forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          const tabName = button.getAttribute('data-tab');
          tabPanes.forEach(pane => {
            pane.classList.toggle('active', pane.id === tabName + 'Tab');
          });

          if (tabName === 'videos' && videosTabEl.classList.contains('active')) {
            const currentTopicName = topicTitleElement.textContent;
            if (currentTopicName && currentTopicName !== 'Loading Topic...' && currentTopicName !== 'Error: Topic ID not found.' && currentTopicName !== 'Authentication Error' && currentTopicName !== 'Error Loading Topic') {
              const hasContent = videosTabEl.querySelector('.video-item');
              if (!hasContent) {
                fetchAndRenderYouTubeVideos(topicId, currentTopicName);
              }
            }
          }
        });
      });

      async function fetchTopicDetails() {
        const userId = localStorage.getItem('userId');
        const accessToken = localStorage.getItem('accessToken');
        if (!userId || !accessToken) {
          document.getElementById('topicName').textContent = 'Authentication Error';
          document.getElementById('topicEmoji').textContent = 'ðŸ”’';
          [conversationsTabEl, bookmarksTabEl, notesTabEl, keyConceptsTab, videosTabEl]
            .forEach(tab => tab.innerHTML = '<p>Please log in to view topic details.</p>');
          return;
        }

        // Show loading spinners for all tabs
        [conversationsTabEl, bookmarksTabEl, notesTabEl, videosTabEl].forEach(tab => {
          if (tab.id === 'bookmarksTab') {
            const container = document.getElementById('topicViewBookmarksList');
            if (container) {
              container.innerHTML = '<div class="loading-spinner-container" style="min-height: 100px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-spinner fa-spin fa-2x text-gray-400"></i></div>';
            }
          } else if (tab.id === 'notesTab') {
            const container = document.getElementById('topicViewNotesList');
            if (container) {
              container.innerHTML = '<div class="loading-spinner-container" style="min-height: 100px; display: flex; align-items: center; justify-content: center;"><i class="fas fa-spinner fa-spin fa-2x text-gray-400"></i></div>';
            }
          } else if (tab.id === 'keyConceptsTab' && keyConceptsContentPlaceholder) {
            keyConceptsContentPlaceholder.innerHTML = '<div class="loading-spinner-container"><i class="fas fa-spinner fa-spin fa-2x text-gray-400"></i></div>';
          } else {
            tab.innerHTML = '<div class="loading-spinner-container"><i class="fas fa-spinner fa-spin fa-2x text-gray-400"></i></div>';
          }
        });

        try {
          const response = await fetch('/.netlify/functions/dashboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
            body: JSON.stringify({ action: 'getTopicDetails', topicId, userId }),
          });
          if (!response.ok) {
            const errorResult = await response.json().catch(() => ({ error: 'Failed to parse error response.' }));
            throw new Error(errorResult.error || `HTTP error! status: ${response.status}`);
          }
          const data = await response.json();
          // Get topic name and emoji from the topic object returned by the backend
          document.getElementById('topicName').textContent = (data.topic && data.topic.name) ? data.topic.name : 'Topic Details';
          document.getElementById('topicEmoji').textContent = (data.topic && data.topic.emoji) ? data.topic.emoji : 'ðŸ“š';
          renderConversations(data.conversations || []);
          renderBookmarks(data.bookmarks || []);
          renderNotes(data.notes || []);
          renderKeyConcepts(data.keyConcepts || null);
          // Save to cache
          localStorage.setItem(`topicDetails_${topicId}`, JSON.stringify({ timestamp: Date.now(), data }));
        } catch (error) {
          console.error('Error fetching topic details:', error);
          document.getElementById('topicName').textContent = 'Error Loading Topic';
          document.getElementById('topicEmoji').textContent = 'âŒ';
          [conversationsTabEl, bookmarksTabEl, notesTabEl, videosTabEl].forEach(tab => tab.innerHTML = `<p class="text-red-500">Error loading content: ${error.message}</p>`);
          showToast(`Error loading topic details: ${error.message}`, 'error');
          keyConceptsContentPlaceholder.innerHTML = `<p class="text-red-500">Error loading key concepts: ${error.message}</p>`;
        }
      }

      function renderConversations(conversations) {
        if (!conversations || conversations.length === 0) {
          conversationsTabEl.innerHTML = '<p class="text-gray-600 p-4">No conversations recorded for this topic yet.</p>';
          return;
        }
        const html = conversations.map(convo => {
          let messagesHtml;

          // Check if convo has content directly or in a messages array
          if (convo.content) {
            // If conversation has direct content property
            const content = convo.content.replace(/\n/g, '<br>');
            messagesHtml = `<div class="message"><p>${content}</p></div>`;
          } else if (Array.isArray(convo.messages) && convo.messages.length > 0) {
             // If conversation has messages array
             messagesHtml = convo.messages.map(msg => {
                const content = msg.content ? msg.content.replace(/\n/g, '<br>') : 'No content for this message.';
                return `<div class="message ${msg.sender === 'user' ? 'user-message' : 'ai-message'}"><b>${msg.sender === 'user' ? 'You' : 'AI'}:</b> ${content}</div>`;
            }).join('');
          } else {
            // If conversation has no content or messages
            messagesHtml = `<div class="message"><p>View this conversation in the chat interface.</p></div>`;
          }
          return `
            <div class="conversation-item" data-id="${convo.id}">
              <div class="item-meta flex justify-between items-center">
                <span>Conversation from: ${new Date(convo.created_at).toLocaleString()}</span>
                <button class="delete-item-btn text-red-500 hover:text-red-700 p-1" data-type="conversation" data-id="${convo.id}" aria-label="Delete conversation"><i class="fas fa-trash-alt"></i></button>
              </div>
              <div class="item-content flex flex-col space-y-1 mt-2">${messagesHtml}</div>
            </div>
          `;
        }).join('');
        conversationsTabEl.innerHTML = html;
      }

      function renderBookmarks(bookmarks) {
        const bookmarksListContainer = document.getElementById('topicViewBookmarksList');
        // Ensure the form and list container structure is present in bookmarksTabEl
        // This is now handled by the initial HTML replacement for bookmarksTabEl.
        // We just need to populate the list.

        if (!bookmarksListContainer) {
            console.error('Bookmarks list container #topicViewBookmarksList not found.');
            bookmarksTabEl.innerHTML = '<p class="text-red-500 p-4">Error: UI component for bookmarks is missing.</p>';
            return;
        }

        bookmarksListContainer.innerHTML = ''; // Clear previous list items

        if (!bookmarks || bookmarks.length === 0) {
          bookmarksListContainer.innerHTML = '<p class="text-gray-600 p-4 text-center">No bookmarks saved for this topic yet. Add one above!</p>';
          return;
        }
        renderActualBookmarks(bookmarks, bookmarksListContainer);
      }

      function renderActualBookmarks(bookmarks, container) {
        bookmarks.forEach(bookmark => {
          const bookmarkItem = document.createElement('div');
          bookmarkItem.className = 'bg-white rounded-lg shadow-sm p-5 hover:shadow-md transition-shadow';
          bookmarkItem.dataset.id = bookmark.id;

          let displayUrl = bookmark.url;
          let hostname = displayUrl;
          try {
            const urlObj = new URL(bookmark.url);
            hostname = urlObj.hostname;
            displayUrl = urlObj.hostname + (urlObj.pathname === '/' ? '' : urlObj.pathname);
          } catch (e) { /* Use original URL if parsing fails */ }
          
          const title = bookmark.title || displayUrl;

          bookmarkItem.innerHTML = `
            <div class="flex justify-between items-start">
              <div class="flex-grow overflow-hidden mr-2">
                <a href="${escapeHTML(bookmark.url)}" target="_blank" rel="noopener noreferrer" title="${escapeHTML(bookmark.url)}" class="text-gray-800 hover:text-blue-600 transition-colors break-words text-lg font-medium">
                  ${escapeHTML(title)}
                </a>
                ${ (bookmark.title && bookmark.title !== displayUrl) ? `<p class="text-xs text-gray-500 break-words truncate" title="${escapeHTML(displayUrl)}">${escapeHTML(hostname)}</p>` : ''}
                <p class="text-xs text-gray-400 mt-1">Added: ${new Date(bookmark.created_at).toLocaleDateString()}</p>
              </div>
              <button class="delete-bookmark-topic-view-btn text-red-500 hover:text-red-700 transition-colors p-1 flex-shrink-0" data-id="${bookmark.id}" aria-label="Delete bookmark">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          `;
          container.appendChild(bookmarkItem);
          const deleteBtn = bookmarkItem.querySelector('.delete-bookmark-topic-view-btn');
          if (deleteBtn) {
            deleteBtn.addEventListener('click', handleDeleteBookmarkTopicView);
          }
        });
        // Listener for form is now attached in DOMContentLoaded
      }

      function renderNotes(notes) {
        const notesListContainer = document.getElementById('topicViewNotesList');
        if (!notesListContainer) {
          notesTabEl.innerHTML = '<p class="text-red-500 p-4">Error: UI component for notes is missing.</p>';
          return;
        }
        notesListContainer.innerHTML = '';
        if (!notes || notes.length === 0) {
          notesListContainer.innerHTML = '<p class="text-gray-600 p-4 text-center">No notes saved for this topic yet. Add one above!</p>';
          return;
        }
        notes.forEach(note => {
          const noteItem = document.createElement('div');
          noteItem.className = 'note-item bg-white rounded-lg shadow-sm p-5 hover:shadow-md transition-shadow';
          noteItem.dataset.id = note.id;

          noteItem.innerHTML = `
            <div class="item-meta flex justify-between items-center">
              <span>Created: ${new Date(note.created_at).toLocaleString()}</span>
              <button class="delete-note-topic-view-btn text-red-500 hover:text-red-700 p-1" data-id="${note.id}" aria-label="Delete note"><i class="fas fa-trash-alt"></i></button>
            </div>
            <div class="item-content mt-2"><p>${note.content ? note.content.replace(/\n/g, '<br>') : 'No content'}</p></div>
          `;
          notesListContainer.appendChild(noteItem);
          const deleteBtn = noteItem.querySelector('.delete-note-topic-view-btn');
          if (deleteBtn) {
            deleteBtn.addEventListener('click', async () => {
              if (!confirm('Are you sure you want to delete this note?')) return;
              const accessToken = localStorage.getItem('accessToken');
              const noteId = deleteBtn.dataset.id;
              try {
                const response = await fetch('/.netlify/functions/dashboard', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
                  body: JSON.stringify({ action: 'deleteNote', noteId })
                });
                const result = await response.json();
                if (response.ok) {
                  showToast('Note deleted successfully.', 'success');
                  fetchTopicDetails();
                } else {
                  showToast(result.error || 'Failed to delete note.', 'error');
                }
              } catch (error) {
                console.error('Error deleting note:', error);
                showToast('An error occurred while deleting the note.', 'error');
              }
            });
          }
        });
      }

      function renderYouTubeVideos(videos, topicName) {
        let headerHtml = '';
        if (topicName) {
          headerHtml = `<p class="text-gray-700 mb-3 text-sm">Showing YouTube results for: <strong>${escapeHTML(topicName)}</strong></p>`;
        }

        if (!videos || videos.length === 0) {
          videosTabEl.innerHTML = headerHtml + '<p class="text-gray-600 p-4">No videos found for this topic.</p>';
          return;
        }
        const html = videos.map(video => `
          <div class="video-item" style="border: 1px solid #e5e7eb; border-radius: 0.375rem; padding: 1rem; margin-bottom: 0.75rem; background-color: #f9fafb;">
            <a href="https://www.youtube.com/watch?v=${video.videoId}" target="_blank" rel="noopener noreferrer" style="display: flex; text-decoration: none; color: inherit;">
              <img src="${video.thumbnailUrl}" alt="${video.title}" style="width: 120px; height: 90px; object-fit: cover; border-radius: 0.25rem; margin-right: 1rem;">
              <div style="flex-grow: 1;">
                <h4 style="font-weight: 600; margin-bottom: 0.25rem; word-break: break-word;">${video.title}</h4>
                <p style="font-size: 0.875rem; color: #6b7280;">${video.channelTitle}</p>
                <p style="font-size: 0.75rem; color: #9ca3af;">Published: ${new Date(video.publishedAt).toLocaleDateString()}</p>
              </div>
            </a>
          </div>
        `).join('');
        videosTabEl.innerHTML = headerHtml + html;
      }

      async function fetchAndRenderYouTubeVideos(topicId, topicName) {
        videosTabEl.innerHTML = '<div class="loading-spinner-container"><i class="fas fa-spinner fa-spin fa-2x text-gray-400"></i></div>';
        const accessToken = localStorage.getItem('accessToken');
        if (!accessToken) {
            videosTabEl.innerHTML = '<p class="text-red-500 p-4">Authentication error. Please log in.</p>';
            return;
        }

        try {
          const response = await fetch('/.netlify/functions/get-youtube-recommendations', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` }, // Added Auth header just in case, though API key is main auth for YouTube
            body: JSON.stringify({ topicId, topicName }),
          });
          if (!response.ok) {
            const errorResult = await response.json().catch(() => ({ error: 'Failed to parse error response from video recommendations.' }));
            throw new Error(errorResult.error || `HTTP error! status: ${response.status}`);
          }
          const videos = await response.json();
          renderYouTubeVideos(videos, topicName);
        } catch (error) {
          console.error('Error fetching YouTube videos:', error);
          videosTabEl.innerHTML = `<p class="text-red-500 p-4">Error loading videos: ${error.message}</p>`;
        }
      }

      // Helper function to escape HTML to prevent XSS, if not already available in utils.js
      function escapeHTML(str) {
        if (typeof str !== 'string') return '';
        return str.replace(/[&<>'"/]/g, function (s) {
          return {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#39;',
            '/': '&#x2F;'
          }[s];
        });
      }

      function renderKeyConcepts(keyConceptData) {
    keyConceptsSpinner.style.display = 'none';
    generateKeyConceptsBtn.disabled = false;

    if (keyConceptData && keyConceptData.content) {
        let html = '';
        const rawContent = keyConceptData.content;
        const lines = rawContent.split('\n');
        const processedParagraphs = [];

        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine === '') continue; // Skip empty lines, but preserve paragraph breaks from non-empty lines

            let lineHtml = '';
            // Split the line by **...** to handle bolding correctly with HTML escaping.
            // The regex /\*\*(.*?)\*\*/g splits the string and includes the captured bolded content in the resulting array.
            const parts = trimmedLine.split(/\*\*(.*?)\*\*/g);

            for (let i = 0; i < parts.length; i++) {
                if (parts[i] === undefined) continue;
                // Odd indices are the captured groups (text that was bolded).
                if (i % 2 === 1) {
                    lineHtml += `<strong>${escapeHTML(parts[i])}</strong>`;
                } else {
                    // Even indices are the normal text segments.
                    lineHtml += escapeHTML(parts[i]);
                }
            }
            processedParagraphs.push(`<p class="text-gray-700 leading-relaxed mb-3">${lineHtml}</p>`);
        }
        
        html = processedParagraphs.join('');

        if (html.trim() === '') {
            // This case handles if content was only whitespace lines
            html = '<p class="text-gray-600">No key concepts content found.</p>';
        }
        
        keyConceptsContentPlaceholder.innerHTML = html;
        generateKeyConceptsBtn.textContent = 'Regenerate Key Concepts';
        keyConceptsStatusEl.textContent = `Last generated: ${new Date(keyConceptData.updated_at).toLocaleString()}`;
    } else {
        keyConceptsContentPlaceholder.innerHTML = '<p class="text-gray-600">No key concepts available. Click the button to generate them.</p>';
        generateKeyConceptsBtn.textContent = 'Generate Key Concepts';
        keyConceptsStatusEl.textContent = '';
    }
}

      generateKeyConceptsBtn.addEventListener('click', async () => {
        generateKeyConceptsBtn.disabled = true;
        keyConceptsSpinner.classList.remove('d-none'); // Show spinner
        const userId = localStorage.getItem('userId');
        const accessToken = localStorage.getItem('accessToken');
        try {
          const response = await fetch('/.netlify/functions/dashboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
            body: JSON.stringify({ action: 'generateKeyConcepts', topicId, userId }),
          });
          const result = await response.json();
          if (response.ok) {
            renderKeyConcepts(result.keyConcepts); // Expecting 'keyConcepts' from backend
            showToast('Key concepts generated successfully!', 'success');
          } else { throw new Error(result.error || 'Failed to generate key concepts'); }
        } catch (error) {
          console.error('Error generating key concepts:', error);
          showToast(`Error generating key concepts: ${error.message}`, 'error');
          keyConceptsSpinner.style.display = 'none'; // Explicitly hide spinner on error
          generateKeyConceptsBtn.disabled = false; // Re-enable button on error
          // Consider if button text needs to be reverted based on state
          // For example, if (keyConceptsContentPlaceholder.textContent.includes("No key concepts available")) { generateKeyConceptsBtn.textContent = 'Generate Key Concepts'; } else { generateKeyConceptsBtn.textContent = 'Regenerate Key Concepts'; }
        }
      });

      // Placeholder delete functions - these should call the backend and update UI
      async function deleteItem(type, itemId) {
        const userId = localStorage.getItem('userId');
        const accessToken = localStorage.getItem('accessToken');
        if (!userId || !accessToken) {
            showToast('Authentication error.', 'error');
            return false;
        }
        try {
            const response = await fetch('/.netlify/functions/dashboard', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${accessToken}`
                },
                body: JSON.stringify({ action: `delete${type}`, [`${type.toLowerCase()}Id`]: itemId, userId, topicId })
            });
            const result = await response.json();
            if (!response.ok) throw new Error(result.error || `Failed to delete ${type.toLowerCase()}.`);
            
            showToast(`${type} deleted successfully.`, 'success');
            // Remove item from DOM
            const itemElement = document.querySelector(`.${type.toLowerCase()}-item[data-id="${itemId}"]`);
            if (itemElement) itemElement.remove();
            
            // Check if tab is empty
            const tabContent = document.getElementById(`${type.toLowerCase()}sTab`);
            if (tabContent && !tabContent.querySelector(`.${type.toLowerCase()}-item`)) {
                tabContent.innerHTML = `<p class="text-gray-500">No ${type.toLowerCase()}s found for this topic.</p>`;
            }
            return true;
        } catch (error) {
            console.error(`Error deleting ${type.toLowerCase()}:`, error);
            showToast(error.message, 'error');
            return false;
        }
      }

      async function deleteConversation(conversationId) { await deleteItem('Conversation', conversationId); }
      async function deleteBookmark(bookmarkId) { await deleteItem('Bookmark', bookmarkId); }
      async function deleteNote(noteId) { await deleteItem('Note', noteId); }

      // Handle add note in Topic View
      async function handleAddNoteTopicView(event) {
        event.preventDefault();
        const accessToken = localStorage.getItem('accessToken');
        const urlParams = new URLSearchParams(window.location.search);
        const topicId = urlParams.get('topicId');
        const contentEl = document.getElementById('topicViewNoteContent');
        const noteContent = contentEl.value.trim();
        if (!noteContent) {
          showToast('Please enter some note content.', 'error');
          return;
        }
        try {
          const response = await fetch('/.netlify/functions/dashboard', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${accessToken}` },
            body: JSON.stringify({ action: 'saveNote', topicId, content: noteContent })
          });
          const result = await response.json();
          if (response.ok) {
            showToast('Note added successfully!', 'success');
            contentEl.value = '';
            fetchTopicDetails();
          } else {
            showToast(result.error || 'Failed to add note.', 'error');
          }
        } catch (error) {
          console.error('Error adding note:', error);
          showToast('An error occurred while adding the note.', 'error');
        }
      }

      // Initial fetch
      fetchTopicDetailsCached();
    });
  </script>
</body>
</html>
